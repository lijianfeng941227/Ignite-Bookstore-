/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bench4Q.cacheConfig;

import java.sql.Types;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.sql.DataSource;

import org.apache.ignite.cache.CacheAtomicityMode;
import org.apache.ignite.cache.QueryEntity;
import org.apache.ignite.cache.QueryIndex;
import org.apache.ignite.cache.store.jdbc.CacheJdbcPojoStoreFactory;
import org.apache.ignite.cache.store.jdbc.JdbcType;
import org.apache.ignite.cache.store.jdbc.JdbcTypeField;
import org.apache.ignite.configuration.CacheConfiguration;
import org.bench4Q.datasource.DataSourceFactory;

/**
 * CacheConfig definition.
 *
 * Code generated by Apache Ignite Schema Import utility: 09/27/2016.
 */
public class CacheConfig {
    /**
     * Create JDBC type for address.
     *
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     */
    private static JdbcType jdbcTypeAddress(String cacheName) {
        JdbcType jdbcType = new JdbcType();

        jdbcType.setCacheName(cacheName);
        jdbcType.setDatabaseSchema("bookstore");
        jdbcType.setDatabaseTable("address");
        jdbcType.setKeyType("org.bench4Q.bean.AddressKey");
        jdbcType.setValueType("org.bench4Q.bean.Address");

        // Key fields for address.
        Collection<JdbcTypeField> keys = new ArrayList<>();
        keys.add(new JdbcTypeField(Types.INTEGER, "ADDR_ID", int.class, "addrId"));
        jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

        // Value fields for address.
        Collection<JdbcTypeField> vals = new ArrayList<>();
        vals.add(new JdbcTypeField(Types.INTEGER, "ADDR_ID", int.class, "addrId"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "ADDR_STREET1", String.class, "addrStreet1"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "ADDR_STREET2", String.class, "addrStreet2"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "ADDR_CITY", String.class, "addrCity"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "ADDR_STATE", String.class, "addrState"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "ADDR_ZIP", String.class, "addrZip"));
        vals.add(new JdbcTypeField(Types.INTEGER, "ADDR_CO_ID", Integer.class, "addrCoId"));
        jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

        return jdbcType;
    }

    /**
     * Create SQL Query descriptor for address.
     *
     * @return Configured query entity.
     */
    private static QueryEntity queryEntityAddress() {
        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("org.bench4Q.bean.AddressKey");
        qryEntity.setValueType("org.bench4Q.bean.Address");

        // Query fields for address.
        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("addrId", "java.lang.Integer");
        fields.put("addrStreet1", "java.lang.String");
        fields.put("addrStreet2", "java.lang.String");
        fields.put("addrCity", "java.lang.String");
        fields.put("addrState", "java.lang.String");
        fields.put("addrZip", "java.lang.String");
        fields.put("addrCoId", "java.lang.Integer");

        qryEntity.setFields(fields);

        // Aliases for fields.
        Map<String, String> aliases = new HashMap<>();

        aliases.put("addrId", "ADDR_ID");
        aliases.put("addrStreet1", "ADDR_STREET1");
        aliases.put("addrStreet2", "ADDR_STREET2");
        aliases.put("addrCity", "ADDR_CITY");
        aliases.put("addrState", "ADDR_STATE");
        aliases.put("addrZip", "ADDR_ZIP");
        aliases.put("addrCoId", "ADDR_CO_ID");

        qryEntity.setAliases(aliases);

        // Indexes for address.
        Collection<QueryIndex> idxs = new ArrayList<>();

        idxs.add(new QueryIndex("addrId", true, "PRIMARY"));

        qryEntity.setIndexes(idxs);

        return qryEntity;
    }

    /**
     * Create JDBC type for author.
     *
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     */
    private static JdbcType jdbcTypeAuthor(String cacheName) {
        JdbcType jdbcType = new JdbcType();

        jdbcType.setCacheName(cacheName);
        jdbcType.setDatabaseSchema("bookstore");
        jdbcType.setDatabaseTable("author");
        jdbcType.setKeyType("org.bench4Q.bean.AuthorKey");
        jdbcType.setValueType("org.bench4Q.bean.Author");

        // Key fields for author.
        Collection<JdbcTypeField> keys = new ArrayList<>();
        keys.add(new JdbcTypeField(Types.INTEGER, "A_ID", int.class, "aId"));
        jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

        // Value fields for author.
        Collection<JdbcTypeField> vals = new ArrayList<>();
        vals.add(new JdbcTypeField(Types.INTEGER, "A_ID", int.class, "aId"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "A_FNAME", String.class, "aFname"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "A_LNAME", String.class, "aLname"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "A_MNAME", String.class, "aMname"));
        vals.add(new JdbcTypeField(Types.DATE, "A_DOB", java.sql.Date.class, "aDob"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "A_BIO", String.class, "aBio"));
        jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

        return jdbcType;
    }

    /**
     * Create SQL Query descriptor for author.
     *
     * @return Configured query entity.
     */
    private static QueryEntity queryEntityAuthor() {
        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("org.bench4Q.bean.AuthorKey");
        qryEntity.setValueType("org.bench4Q.bean.Author");

        // Query fields for author.
        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("aId", "java.lang.Integer");
        fields.put("aFname", "java.lang.String");
        fields.put("aLname", "java.lang.String");
        fields.put("aMname", "java.lang.String");
        fields.put("aDob", "java.sql.Date");
        fields.put("aBio", "java.lang.String");

        qryEntity.setFields(fields);

        // Aliases for fields.
        Map<String, String> aliases = new HashMap<>();

        aliases.put("aId", "A_ID");
        aliases.put("aFname", "A_FNAME");
        aliases.put("aLname", "A_LNAME");
        aliases.put("aMname", "A_MNAME");
        aliases.put("aDob", "A_DOB");
        aliases.put("aBio", "A_BIO");

        qryEntity.setAliases(aliases);

        // Indexes for author.
        Collection<QueryIndex> idxs = new ArrayList<>();

        idxs.add(new QueryIndex("aId", true, "PRIMARY"));

        qryEntity.setIndexes(idxs);

        return qryEntity;
    }

    /**
     * Create JDBC type for cc_xacts.
     *
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     */
    private static JdbcType jdbcTypeCcXacts(String cacheName) {
        JdbcType jdbcType = new JdbcType();

        jdbcType.setCacheName(cacheName);
        jdbcType.setDatabaseSchema("bookstore");
        jdbcType.setDatabaseTable("cc_xacts");
        jdbcType.setKeyType("org.bench4Q.bean.CcXactsKey");
        jdbcType.setValueType("org.bench4Q.bean.CcXacts");

        // Key fields for cc_xacts.
        Collection<JdbcTypeField> keys = new ArrayList<>();
        keys.add(new JdbcTypeField(Types.INTEGER, "CX_O_ID", int.class, "cxOId"));
        jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

        // Value fields for cc_xacts.
        Collection<JdbcTypeField> vals = new ArrayList<>();
        vals.add(new JdbcTypeField(Types.INTEGER, "CX_O_ID", int.class, "cxOId"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "CX_TYPE", String.class, "cxType"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "CX_NUM", String.class, "cxNum"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "CX_NAME", String.class, "cxName"));
        vals.add(new JdbcTypeField(Types.DATE, "CX_EXPIRE", java.sql.Date.class, "cxExpire"));
        vals.add(new JdbcTypeField(Types.CHAR, "CX_AUTH_ID", String.class, "cxAuthId"));
        vals.add(new JdbcTypeField(Types.DOUBLE, "CX_XACT_AMT", Double.class, "cxXactAmt"));
        vals.add(new JdbcTypeField(Types.DATE, "CX_XACT_DATE", java.sql.Date.class, "cxXactDate"));
        vals.add(new JdbcTypeField(Types.INTEGER, "CX_CO_ID", Integer.class, "cxCoId"));
        jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

        return jdbcType;
    }

    /**
     * Create SQL Query descriptor for cc_xacts.
     *
     * @return Configured query entity.
     */
    private static QueryEntity queryEntityCcXacts() {
        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("org.bench4Q.bean.CcXactsKey");
        qryEntity.setValueType("org.bench4Q.bean.CcXacts");

        // Query fields for cc_xacts.
        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("cxOId", "java.lang.Integer");
        fields.put("cxType", "java.lang.String");
        fields.put("cxNum", "java.lang.String");
        fields.put("cxName", "java.lang.String");
        fields.put("cxExpire", "java.sql.Date");
        fields.put("cxAuthId", "java.lang.String");
        fields.put("cxXactAmt", "java.lang.Double");
        fields.put("cxXactDate", "java.sql.Date");
        fields.put("cxCoId", "java.lang.Integer");

        qryEntity.setFields(fields);

        // Aliases for fields.
        Map<String, String> aliases = new HashMap<>();

        aliases.put("cxOId", "CX_O_ID");
        aliases.put("cxType", "CX_TYPE");
        aliases.put("cxNum", "CX_NUM");
        aliases.put("cxName", "CX_NAME");
        aliases.put("cxExpire", "CX_EXPIRE");
        aliases.put("cxAuthId", "CX_AUTH_ID");
        aliases.put("cxXactAmt", "CX_XACT_AMT");
        aliases.put("cxXactDate", "CX_XACT_DATE");
        aliases.put("cxCoId", "CX_CO_ID");

        qryEntity.setAliases(aliases);

        // Indexes for cc_xacts.
        Collection<QueryIndex> idxs = new ArrayList<>();

        idxs.add(new QueryIndex("cxOId", true, "PRIMARY"));

        qryEntity.setIndexes(idxs);

        return qryEntity;
    }

    /**
     * Create JDBC type for country.
     *
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     */
    private static JdbcType jdbcTypeCountry(String cacheName) {
        JdbcType jdbcType = new JdbcType();

        jdbcType.setCacheName(cacheName);
        jdbcType.setDatabaseSchema("bookstore");
        jdbcType.setDatabaseTable("country");
        jdbcType.setKeyType("org.bench4Q.bean.CountryKey");
        jdbcType.setValueType("org.bench4Q.bean.Country");

        // Key fields for country.
        Collection<JdbcTypeField> keys = new ArrayList<>();
        keys.add(new JdbcTypeField(Types.INTEGER, "CO_ID", int.class, "coId"));
        jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

        // Value fields for country.
        Collection<JdbcTypeField> vals = new ArrayList<>();
        vals.add(new JdbcTypeField(Types.INTEGER, "CO_ID", int.class, "coId"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "CO_NAME", String.class, "coName"));
        vals.add(new JdbcTypeField(Types.DOUBLE, "CO_EXCHANGE", Double.class, "coExchange"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "CO_CURRENCY", String.class, "coCurrency"));
        jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

        return jdbcType;
    }

    /**
     * Create SQL Query descriptor for country.
     *
     * @return Configured query entity.
     */
    private static QueryEntity queryEntityCountry() {
        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("org.bench4Q.bean.CountryKey");
        qryEntity.setValueType("org.bench4Q.bean.Country");

        // Query fields for country.
        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("coId", "java.lang.Integer");
        fields.put("coName", "java.lang.String");
        fields.put("coExchange", "java.lang.Double");
        fields.put("coCurrency", "java.lang.String");

        qryEntity.setFields(fields);

        // Aliases for fields.
        Map<String, String> aliases = new HashMap<>();

        aliases.put("coId", "CO_ID");
        aliases.put("coName", "CO_NAME");
        aliases.put("coExchange", "CO_EXCHANGE");
        aliases.put("coCurrency", "CO_CURRENCY");

        qryEntity.setAliases(aliases);

        // Indexes for country.
        Collection<QueryIndex> idxs = new ArrayList<>();

        idxs.add(new QueryIndex("coId", true, "PRIMARY"));

        qryEntity.setIndexes(idxs);

        return qryEntity;
    }

    /**
     * Create JDBC type for customer.
     *
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     */
    private static JdbcType jdbcTypeCustomer(String cacheName) {
        JdbcType jdbcType = new JdbcType();

        jdbcType.setCacheName(cacheName);
        jdbcType.setDatabaseSchema("bookstore");
        jdbcType.setDatabaseTable("customer");
        jdbcType.setKeyType("org.bench4Q.bean.CustomerKey");
        jdbcType.setValueType("org.bench4Q.bean.Customer");

        // Key fields for customer.
        Collection<JdbcTypeField> keys = new ArrayList<>();
        keys.add(new JdbcTypeField(Types.INTEGER, "C_ID", int.class, "cId"));
        jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

        // Value fields for customer.
        Collection<JdbcTypeField> vals = new ArrayList<>();
        vals.add(new JdbcTypeField(Types.INTEGER, "C_ID", int.class, "cId"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "C_UNAME", String.class, "cUname"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "C_PASSWD", String.class, "cPasswd"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "C_FNAME", String.class, "cFname"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "C_LNAME", String.class, "cLname"));
        vals.add(new JdbcTypeField(Types.INTEGER, "C_ADDR_ID", Integer.class, "cAddrId"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "C_PHONE", String.class, "cPhone"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "C_EMAIL", String.class, "cEmail"));
        vals.add(new JdbcTypeField(Types.DATE, "C_SINCE", java.sql.Date.class, "cSince"));
        vals.add(new JdbcTypeField(Types.DATE, "C_LAST_LOGIN", java.sql.Date.class, "cLastLogin"));
        vals.add(new JdbcTypeField(Types.TIMESTAMP, "C_LOGIN", java.sql.Timestamp.class, "cLogin"));
        vals.add(new JdbcTypeField(Types.TIMESTAMP, "C_EXPIRATION", java.sql.Timestamp.class, "cExpiration"));
        vals.add(new JdbcTypeField(Types.DOUBLE, "C_DISCOUNT", Double.class, "cDiscount"));
        vals.add(new JdbcTypeField(Types.DOUBLE, "C_BALANCE", Double.class, "cBalance"));
        vals.add(new JdbcTypeField(Types.DOUBLE, "C_YTD_PMT", Double.class, "cYtdPmt"));
        vals.add(new JdbcTypeField(Types.DATE, "C_BIRTHDATE", java.sql.Date.class, "cBirthdate"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "C_DATA", String.class, "cData"));
        jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

        return jdbcType;
    }

    /**
     * Create SQL Query descriptor for customer.
     *
     * @return Configured query entity.
     */
    private static QueryEntity queryEntityCustomer() {
        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("org.bench4Q.bean.CustomerKey");
        qryEntity.setValueType("org.bench4Q.bean.Customer");

        // Query fields for customer.
        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("cId", "java.lang.Integer");
        fields.put("cUname", "java.lang.String");
        fields.put("cPasswd", "java.lang.String");
        fields.put("cFname", "java.lang.String");
        fields.put("cLname", "java.lang.String");
        fields.put("cAddrId", "java.lang.Integer");
        fields.put("cPhone", "java.lang.String");
        fields.put("cEmail", "java.lang.String");
        fields.put("cSince", "java.sql.Date");
        fields.put("cLastLogin", "java.sql.Date");
        fields.put("cLogin", "java.sql.Timestamp");
        fields.put("cExpiration", "java.sql.Timestamp");
        fields.put("cDiscount", "java.lang.Double");
        fields.put("cBalance", "java.lang.Double");
        fields.put("cYtdPmt", "java.lang.Double");
        fields.put("cBirthdate", "java.sql.Date");
        fields.put("cData", "java.lang.String");

        qryEntity.setFields(fields);

        // Aliases for fields.
        Map<String, String> aliases = new HashMap<>();

        aliases.put("cId", "C_ID");
        aliases.put("cUname", "C_UNAME");
        aliases.put("cPasswd", "C_PASSWD");
        aliases.put("cFname", "C_FNAME");
        aliases.put("cLname", "C_LNAME");
        aliases.put("cAddrId", "C_ADDR_ID");
        aliases.put("cPhone", "C_PHONE");
        aliases.put("cEmail", "C_EMAIL");
        aliases.put("cSince", "C_SINCE");
        aliases.put("cLastLogin", "C_LAST_LOGIN");
        aliases.put("cLogin", "C_LOGIN");
        aliases.put("cExpiration", "C_EXPIRATION");
        aliases.put("cDiscount", "C_DISCOUNT");
        aliases.put("cBalance", "C_BALANCE");
        aliases.put("cYtdPmt", "C_YTD_PMT");
        aliases.put("cBirthdate", "C_BIRTHDATE");
        aliases.put("cData", "C_DATA");

        qryEntity.setAliases(aliases);

        // Indexes for customer.
        Collection<QueryIndex> idxs = new ArrayList<>();

        idxs.add(new QueryIndex("cId", true, "PRIMARY"));

        qryEntity.setIndexes(idxs);

        return qryEntity;
    }

    /**
     * Create JDBC type for item.
     *
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     */
    private static JdbcType jdbcTypeItem(String cacheName) {
        JdbcType jdbcType = new JdbcType();

        jdbcType.setCacheName(cacheName);
        jdbcType.setDatabaseSchema("bookstore");
        jdbcType.setDatabaseTable("item");
        jdbcType.setKeyType("org.bench4Q.bean.ItemKey");
        jdbcType.setValueType("org.bench4Q.bean.Item");

        // Key fields for item.
        Collection<JdbcTypeField> keys = new ArrayList<>();
        keys.add(new JdbcTypeField(Types.INTEGER, "I_ID", int.class, "iId"));
        jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

        // Value fields for item.
        Collection<JdbcTypeField> vals = new ArrayList<>();
        vals.add(new JdbcTypeField(Types.INTEGER, "I_ID", int.class, "iId"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "I_TITLE", String.class, "iTitle"));
        vals.add(new JdbcTypeField(Types.INTEGER, "I_A_ID", Integer.class, "iAId"));
        vals.add(new JdbcTypeField(Types.DATE, "I_PUB_DATE", java.sql.Date.class, "iPubDate"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "I_PUBLISHER", String.class, "iPublisher"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "I_SUBJECT", String.class, "iSubject"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "I_DESC", String.class, "iDesc"));
        vals.add(new JdbcTypeField(Types.INTEGER, "I_RELATED1", Integer.class, "iRelated1"));
        vals.add(new JdbcTypeField(Types.INTEGER, "I_RELATED2", Integer.class, "iRelated2"));
        vals.add(new JdbcTypeField(Types.INTEGER, "I_RELATED3", Integer.class, "iRelated3"));
        vals.add(new JdbcTypeField(Types.INTEGER, "I_RELATED4", Integer.class, "iRelated4"));
        vals.add(new JdbcTypeField(Types.INTEGER, "I_RELATED5", Integer.class, "iRelated5"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "I_THUMBNAIL", String.class, "iThumbnail"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "I_IMAGE", String.class, "iImage"));
        vals.add(new JdbcTypeField(Types.DOUBLE, "I_SRP", Double.class, "iSrp"));
        vals.add(new JdbcTypeField(Types.DOUBLE, "I_COST", Double.class, "iCost"));
        vals.add(new JdbcTypeField(Types.DATE, "I_AVAIL", java.sql.Date.class, "iAvail"));
        vals.add(new JdbcTypeField(Types.INTEGER, "I_STOCK", Integer.class, "iStock"));
        vals.add(new JdbcTypeField(Types.CHAR, "I_ISBN", String.class, "iIsbn"));
        vals.add(new JdbcTypeField(Types.INTEGER, "I_PAGE", Integer.class, "iPage"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "I_BACKING", String.class, "iBacking"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "I_DIMENSIONS", String.class, "iDimensions"));
        jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

        return jdbcType;
    }

    /**
     * Create SQL Query descriptor for item.
     *
     * @return Configured query entity.
     */
    private static QueryEntity queryEntityItem() {
        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("org.bench4Q.bean.ItemKey");
        qryEntity.setValueType("org.bench4Q.bean.Item");

        // Query fields for item.
        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("iId", "java.lang.Integer");
        fields.put("iTitle", "java.lang.String");
        fields.put("iAId", "java.lang.Integer");
        fields.put("iPubDate", "java.sql.Date");
        fields.put("iPublisher", "java.lang.String");
        fields.put("iSubject", "java.lang.String");
        fields.put("iDesc", "java.lang.String");
        fields.put("iRelated1", "java.lang.Integer");
        fields.put("iRelated2", "java.lang.Integer");
        fields.put("iRelated3", "java.lang.Integer");
        fields.put("iRelated4", "java.lang.Integer");
        fields.put("iRelated5", "java.lang.Integer");
        fields.put("iThumbnail", "java.lang.String");
        fields.put("iImage", "java.lang.String");
        fields.put("iSrp", "java.lang.Double");
        fields.put("iCost", "java.lang.Double");
        fields.put("iAvail", "java.sql.Date");
        fields.put("iStock", "java.lang.Integer");
        fields.put("iIsbn", "java.lang.String");
        fields.put("iPage", "java.lang.Integer");
        fields.put("iBacking", "java.lang.String");
        fields.put("iDimensions", "java.lang.String");

        qryEntity.setFields(fields);

        // Aliases for fields.
        Map<String, String> aliases = new HashMap<>();

        aliases.put("iId", "I_ID");
        aliases.put("iTitle", "I_TITLE");
        aliases.put("iAId", "I_A_ID");
        aliases.put("iPubDate", "I_PUB_DATE");
        aliases.put("iPublisher", "I_PUBLISHER");
        aliases.put("iSubject", "I_SUBJECT");
        aliases.put("iDesc", "I_DESC");
        aliases.put("iRelated1", "I_RELATED1");
        aliases.put("iRelated2", "I_RELATED2");
        aliases.put("iRelated3", "I_RELATED3");
        aliases.put("iRelated4", "I_RELATED4");
        aliases.put("iRelated5", "I_RELATED5");
        aliases.put("iThumbnail", "I_THUMBNAIL");
        aliases.put("iImage", "I_IMAGE");
        aliases.put("iSrp", "I_SRP");
        aliases.put("iCost", "I_COST");
        aliases.put("iAvail", "I_AVAIL");
        aliases.put("iStock", "I_STOCK");
        aliases.put("iIsbn", "I_ISBN");
        aliases.put("iPage", "I_PAGE");
        aliases.put("iBacking", "I_BACKING");
        aliases.put("iDimensions", "I_DIMENSIONS");

        qryEntity.setAliases(aliases);

        // Indexes for item.
        Collection<QueryIndex> idxs = new ArrayList<>();

        idxs.add(new QueryIndex("iId", true, "PRIMARY"));

        qryEntity.setIndexes(idxs);

        return qryEntity;
    }

    /**
     * Create JDBC type for order_line.
     *
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     */
    private static JdbcType jdbcTypeOrderLine(String cacheName) {
        JdbcType jdbcType = new JdbcType();

        jdbcType.setCacheName(cacheName);
        jdbcType.setDatabaseSchema("bookstore");
        jdbcType.setDatabaseTable("order_line");
        jdbcType.setKeyType("org.bench4Q.bean.OrderLineKey");
        jdbcType.setValueType("org.bench4Q.bean.OrderLine");

        // Key fields for order_line.
        Collection<JdbcTypeField> keys = new ArrayList<>();
        keys.add(new JdbcTypeField(Types.INTEGER, "OL_ID", int.class, "olId"));
        keys.add(new JdbcTypeField(Types.INTEGER, "OL_O_ID", int.class, "olOId"));
        jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

        // Value fields for order_line.
        Collection<JdbcTypeField> vals = new ArrayList<>();
        vals.add(new JdbcTypeField(Types.INTEGER, "OL_ID", int.class, "olId"));
        vals.add(new JdbcTypeField(Types.INTEGER, "OL_O_ID", int.class, "olOId"));
        vals.add(new JdbcTypeField(Types.INTEGER, "OL_I_ID", Integer.class, "olIId"));
        vals.add(new JdbcTypeField(Types.INTEGER, "OL_QTY", Integer.class, "olQty"));
        vals.add(new JdbcTypeField(Types.DOUBLE, "OL_DISCOUNT", Double.class, "olDiscount"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "OL_COMMENTS", String.class, "olComments"));
        jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

        return jdbcType;
    }

    /**
     * Create SQL Query descriptor for order_line.
     *
     * @return Configured query entity.
     */
    private static QueryEntity queryEntityOrderLine() {
        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("org.bench4Q.bean.OrderLineKey");
        qryEntity.setValueType("org.bench4Q.bean.OrderLine");

        // Query fields for order_line.
        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("olId", "java.lang.Integer");
        fields.put("olOId", "java.lang.Integer");
        fields.put("olIId", "java.lang.Integer");
        fields.put("olQty", "java.lang.Integer");
        fields.put("olDiscount", "java.lang.Double");
        fields.put("olComments", "java.lang.String");

        qryEntity.setFields(fields);

        // Aliases for fields.
        Map<String, String> aliases = new HashMap<>();

        aliases.put("olId", "OL_ID");
        aliases.put("olOId", "OL_O_ID");
        aliases.put("olIId", "OL_I_ID");
        aliases.put("olQty", "OL_QTY");
        aliases.put("olDiscount", "OL_DISCOUNT");
        aliases.put("olComments", "OL_COMMENTS");

        qryEntity.setAliases(aliases);

        // Indexes for order_line.
        Collection<QueryIndex> idxs = new ArrayList<>();

        QueryIndex idx = new QueryIndex();

        idx.setName("PRIMARY");

        LinkedHashMap<String, Boolean> idxFlds = new LinkedHashMap<>();

        idxFlds.put("olId", true);
        idxFlds.put("olOId", true);

        idx.setFields(idxFlds);

        idxs.add(idx);

        qryEntity.setIndexes(idxs);

        return qryEntity;
    }

    /**
     * Create JDBC type for orders.
     *
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     */
    private static JdbcType jdbcTypeOrders(String cacheName) {
        JdbcType jdbcType = new JdbcType();

        jdbcType.setCacheName(cacheName);
        jdbcType.setDatabaseSchema("bookstore");
        jdbcType.setDatabaseTable("orders");
        jdbcType.setKeyType("org.bench4Q.bean.OrdersKey");
        jdbcType.setValueType("org.bench4Q.bean.Orders");

        // Key fields for orders.
        Collection<JdbcTypeField> keys = new ArrayList<>();
        keys.add(new JdbcTypeField(Types.INTEGER, "O_ID", int.class, "oId"));
        jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

        // Value fields for orders.
        Collection<JdbcTypeField> vals = new ArrayList<>();
        vals.add(new JdbcTypeField(Types.INTEGER, "O_ID", int.class, "oId"));
        vals.add(new JdbcTypeField(Types.INTEGER, "O_C_ID", Integer.class, "oCId"));
        vals.add(new JdbcTypeField(Types.DATE, "O_DATE", java.sql.Date.class, "oDate"));
        vals.add(new JdbcTypeField(Types.DOUBLE, "O_SUB_TOTAL", Double.class, "oSubTotal"));
        vals.add(new JdbcTypeField(Types.DOUBLE, "O_TAX", Double.class, "oTax"));
        vals.add(new JdbcTypeField(Types.DOUBLE, "O_TOTAL", Double.class, "oTotal"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "O_SHIP_TYPE", String.class, "oShipType"));
        vals.add(new JdbcTypeField(Types.DATE, "O_SHIP_DATE", java.sql.Date.class, "oShipDate"));
        vals.add(new JdbcTypeField(Types.INTEGER, "O_BILL_ADDR_ID", Integer.class, "oBillAddrId"));
        vals.add(new JdbcTypeField(Types.INTEGER, "O_SHIP_ADDR_ID", Integer.class, "oShipAddrId"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "O_STATUS", String.class, "oStatus"));
        jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

        return jdbcType;
    }

    /**
     * Create SQL Query descriptor for orders.
     *
     * @return Configured query entity.
     */
    private static QueryEntity queryEntityOrders() {
        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("org.bench4Q.bean.OrdersKey");
        qryEntity.setValueType("org.bench4Q.bean.Orders");

        // Query fields for orders.
        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("oId", "java.lang.Integer");
        fields.put("oCId", "java.lang.Integer");
        fields.put("oDate", "java.sql.Date");
        fields.put("oSubTotal", "java.lang.Double");
        fields.put("oTax", "java.lang.Double");
        fields.put("oTotal", "java.lang.Double");
        fields.put("oShipType", "java.lang.String");
        fields.put("oShipDate", "java.sql.Date");
        fields.put("oBillAddrId", "java.lang.Integer");
        fields.put("oShipAddrId", "java.lang.Integer");
        fields.put("oStatus", "java.lang.String");

        qryEntity.setFields(fields);

        // Aliases for fields.
        Map<String, String> aliases = new HashMap<>();

        aliases.put("oId", "O_ID");
        aliases.put("oCId", "O_C_ID");
        aliases.put("oDate", "O_DATE");
        aliases.put("oSubTotal", "O_SUB_TOTAL");
        aliases.put("oTax", "O_TAX");
        aliases.put("oTotal", "O_TOTAL");
        aliases.put("oShipType", "O_SHIP_TYPE");
        aliases.put("oShipDate", "O_SHIP_DATE");
        aliases.put("oBillAddrId", "O_BILL_ADDR_ID");
        aliases.put("oShipAddrId", "O_SHIP_ADDR_ID");
        aliases.put("oStatus", "O_STATUS");

        qryEntity.setAliases(aliases);

        // Indexes for orders.
        Collection<QueryIndex> idxs = new ArrayList<>();

        idxs.add(new QueryIndex("oId", true, "PRIMARY"));

        qryEntity.setIndexes(idxs);

        return qryEntity;
    }

    /**
     * Create JDBC type for shopping_cart.
     *
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     */
    private static JdbcType jdbcTypeShoppingCart(String cacheName) {
        JdbcType jdbcType = new JdbcType();

        jdbcType.setCacheName(cacheName);
        jdbcType.setDatabaseSchema("bookstore");
        jdbcType.setDatabaseTable("shopping_cart");
        jdbcType.setKeyType("org.bench4Q.bean.ShoppingCartKey");
        jdbcType.setValueType("org.bench4Q.bean.ShoppingCart");

        // Key fields for shopping_cart.
        Collection<JdbcTypeField> keys = new ArrayList<>();
        keys.add(new JdbcTypeField(Types.INTEGER, "SC_ID", int.class, "scId"));
        jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

        // Value fields for shopping_cart.
        Collection<JdbcTypeField> vals = new ArrayList<>();
        vals.add(new JdbcTypeField(Types.INTEGER, "SC_ID", int.class, "scId"));
        vals.add(new JdbcTypeField(Types.TIMESTAMP, "SC_TIME", java.sql.Timestamp.class, "scTime"));
        jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

        return jdbcType;
    }

    /**
     * Create SQL Query descriptor for shopping_cart.
     *
     * @return Configured query entity.
     */
    private static QueryEntity queryEntityShoppingCart() {
        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("org.bench4Q.bean.ShoppingCartKey");
        qryEntity.setValueType("org.bench4Q.bean.ShoppingCart");

        // Query fields for shopping_cart.
        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("scId", "java.lang.Integer");
        fields.put("scTime", "java.sql.Timestamp");

        qryEntity.setFields(fields);

        // Aliases for fields.
        Map<String, String> aliases = new HashMap<>();

        aliases.put("scId", "SC_ID");
        aliases.put("scTime", "SC_TIME");

        qryEntity.setAliases(aliases);

        // Indexes for shopping_cart.
        Collection<QueryIndex> idxs = new ArrayList<>();

        idxs.add(new QueryIndex("scId", true, "PRIMARY"));

        qryEntity.setIndexes(idxs);

        return qryEntity;
    }

    /**
     * Create JDBC type for shopping_cart_line.
     *
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     */
    private static JdbcType jdbcTypeShoppingCartLine(String cacheName) {
        JdbcType jdbcType = new JdbcType();

        jdbcType.setCacheName(cacheName);
        jdbcType.setDatabaseSchema("bookstore");
        jdbcType.setDatabaseTable("shopping_cart_line");
        jdbcType.setKeyType("org.bench4Q.bean.ShoppingCartLineKey");
        jdbcType.setValueType("org.bench4Q.bean.ShoppingCartLine");

        // Key fields for shopping_cart_line.
        Collection<JdbcTypeField> keys = new ArrayList<>();
        keys.add(new JdbcTypeField(Types.INTEGER, "SCL_SC_ID", int.class, "sclScId"));
        keys.add(new JdbcTypeField(Types.INTEGER, "SCL_I_ID", int.class, "sclIId"));
        jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

        // Value fields for shopping_cart_line.
        Collection<JdbcTypeField> vals = new ArrayList<>();
        vals.add(new JdbcTypeField(Types.INTEGER, "SCL_SC_ID", int.class, "sclScId"));
        vals.add(new JdbcTypeField(Types.INTEGER, "SCL_QTY", Integer.class, "sclQty"));
        vals.add(new JdbcTypeField(Types.INTEGER, "SCL_I_ID", int.class, "sclIId"));
        jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

        return jdbcType;
    }

    /**
     * Create SQL Query descriptor for shopping_cart_line.
     *
     * @return Configured query entity.
     */
    private static QueryEntity queryEntityShoppingCartLine() {
        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("org.bench4Q.bean.ShoppingCartLineKey");
        qryEntity.setValueType("org.bench4Q.bean.ShoppingCartLine");

        // Query fields for shopping_cart_line.
        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("sclScId", "java.lang.Integer");
        fields.put("sclQty", "java.lang.Integer");
        fields.put("sclIId", "java.lang.Integer");

        qryEntity.setFields(fields);

        // Aliases for fields.
        Map<String, String> aliases = new HashMap<>();

        aliases.put("sclScId", "SCL_SC_ID");
        aliases.put("sclQty", "SCL_QTY");
        aliases.put("sclIId", "SCL_I_ID");

        qryEntity.setAliases(aliases);

        // Indexes for shopping_cart_line.
        Collection<QueryIndex> idxs = new ArrayList<>();

        QueryIndex idx = new QueryIndex();

        idx.setName("PRIMARY");

        LinkedHashMap<String, Boolean> idxFlds = new LinkedHashMap<>();

        idxFlds.put("sclScId", true);
        idxFlds.put("sclIId", true);

        idx.setFields(idxFlds);

        idxs.add(idx);

        qryEntity.setIndexes(idxs);

        return qryEntity;
    }

    /**
     * Configure cache.
     *
     * @param cacheName Cache name.
     * @param storeFactory Cache store factory.
     * @return Cache configuration.
     */
    public static <K, V> CacheConfiguration<K, V> cache(String cacheName, CacheJdbcPojoStoreFactory<K, V> storeFactory) {
        if (storeFactory == null)
             throw new IllegalArgumentException("Cache store factory cannot be null.");

        CacheConfiguration<K, V> ccfg = new CacheConfiguration<>(cacheName);

        ccfg.setCacheStoreFactory(storeFactory);
        ccfg.setReadThrough(true);
        ccfg.setWriteThrough(true);

        // Configure JDBC types. 
        Collection<JdbcType> jdbcTypes = new ArrayList<>();
        //根据缓存名加入指定类型配置type信息
        if (cacheName == "Address") {
			jdbcTypes.add(jdbcTypeAddress(cacheName));
		}
        if (cacheName == "Author") {
		jdbcTypes.add(jdbcTypeAuthor(cacheName));
        }
        if (cacheName == "CcXacts"){
		jdbcTypes.add(jdbcTypeCcXacts(cacheName));
        }
        if (cacheName == "Country"){
        	System.out.println("Country");
		jdbcTypes.add(jdbcTypeCountry(cacheName));
        }
        if (cacheName == "Customer"){
        jdbcTypes.add(jdbcTypeCustomer(cacheName));
        }
        if (cacheName == "Item"){
        jdbcTypes.add(jdbcTypeItem(cacheName));
        }
        if (cacheName == "OrderLine"){
        jdbcTypes.add(jdbcTypeOrderLine(cacheName));
        }
        if (cacheName == "Orders"){
        jdbcTypes.add(jdbcTypeOrders(cacheName));
        }
        if (cacheName == "ShoppingCart"){
        jdbcTypes.add(jdbcTypeShoppingCart(cacheName));
        }
        if (cacheName == "ShoppingCartLine"){
        jdbcTypes.add(jdbcTypeShoppingCartLine(cacheName));
        }
	
        
  /*      jdbcTypes.add(jdbcTypeAddress(cacheName));
		jdbcTypes.add(jdbcTypeAuthor(cacheName));
		jdbcTypes.add(jdbcTypeCcXacts(cacheName));
		jdbcTypes.add(jdbcTypeCountry(cacheName));
        jdbcTypes.add(jdbcTypeCustomer(cacheName));
        jdbcTypes.add(jdbcTypeItem(cacheName));
        jdbcTypes.add(jdbcTypeOrderLine(cacheName));
        jdbcTypes.add(jdbcTypeOrders(cacheName));
        jdbcTypes.add(jdbcTypeShoppingCart(cacheName));
        jdbcTypes.add(jdbcTypeShoppingCartLine(cacheName));*/
        
        
        storeFactory.setTypes(jdbcTypes.toArray(new JdbcType[jdbcTypes.size()]));

        // Configure query entities. 
        Collection<QueryEntity> qryEntities = new ArrayList<>();
        
        //根据缓存名加入指定类型配置type信息
        if (cacheName == "Address"){
        qryEntities.add(queryEntityAddress());
        }
        if (cacheName == "Author"){
        qryEntities.add(queryEntityAuthor());
        }
        if (cacheName == "CcXacts"){
        qryEntities.add(queryEntityCcXacts());
        }
        if (cacheName == "Country"){
        qryEntities.add(queryEntityCountry());
        }
        if (cacheName == "Customer"){
        qryEntities.add(queryEntityCustomer());
        }
        if (cacheName == "Item"){
        qryEntities.add(queryEntityItem());
        }
        if (cacheName == "OrderLine"){
        qryEntities.add(queryEntityOrderLine());
        }
        if (cacheName == "Orders"){
        qryEntities.add(queryEntityOrders());
        }
        if (cacheName == "ShoppingCart"){
        qryEntities.add(queryEntityShoppingCart());
        }
        if (cacheName == "ShoppingCartLine"){
        qryEntities.add(queryEntityShoppingCartLine());
        }
        
/*            qryEntities.add(queryEntityAddress());
            qryEntities.add(queryEntityAuthor());
            qryEntities.add(queryEntityCcXacts());
            qryEntities.add(queryEntityCountry());
            qryEntities.add(queryEntityCustomer());
            qryEntities.add(queryEntityItem());
            qryEntities.add(queryEntityOrderLine());
            qryEntities.add(queryEntityOrders());
            qryEntities.add(queryEntityShoppingCart());
            qryEntities.add(queryEntityShoppingCartLine());*/
        
        
        ccfg.setQueryEntities(qryEntities);

        return ccfg;
    }
    
/**
 * 获取缓存配置
 * @return
 * @throws Exception
 */
    public static CacheConfiguration<Object,Object> getCacheConfiguration(String cacheName) throws Exception {

    	CacheJdbcPojoStoreFactory<Object, Object> cacheJdbcPojoStoreFactory = new CacheJdbcPojoStoreFactory<Object, Object>();
    	//设置数据源
 /*   	Context initContext = new InitialContext();
    	
  	    Context envContext = (Context)initContext.lookup("java:/comp/env");  
  	    
  	    DataSource ds = (DataSource)envContext.lookup("jdbc/bench4q");*/
    	
/*    	DriverManagerDataSource ds=new DriverManagerDataSource("jdbc:mysql://localhost:3306/bookstore", "root", "1234");
		ds.setDriverClassName("com.mysql.jdbc.Driver");*/
    	
//    	cacheJdbcPojoStoreFactory.setDataSource(ds);
  	    cacheJdbcPojoStoreFactory.setDataSourceFactory(new DataSourceFactory<DataSource>());
    	cacheJdbcPojoStoreFactory.setParallelLoadCacheMinimumThreshold(200);
    	CacheConfiguration<Object, Object> ccfg = cache(cacheName,cacheJdbcPojoStoreFactory);
    	
    	//为Cache开启事务配置
    	ccfg.setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL);
    	
    	
    
    	return ccfg;
    	
	}
}
